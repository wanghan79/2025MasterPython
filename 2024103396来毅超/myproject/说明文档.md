# 基于 LLM 的组合优化系统 —— 图中关键节点选择
### 项目背景与目标

目标任务是：寻找图中一组关键节点，其删除后能最大限度地减小最大连通子图（GCC）规模。这是一个典型的组合优化问题，广泛应用于网络鲁棒性分析、病毒传播控制、信息阻断等场景。

本项目利用**大语言模型（LLM）**的代码生成与改写能力，通过遗传算法思路（初始化、交叉、变异、筛选）自动优化图算法函数 score_nodes()，并通过评估函数对其打分，循环进化优化。

### 模块结构概览
InitializationModule	生成初始算法集合（LLM/手工）
CrossoverModule	将两个算法融合生成新算法（函数级“重组”）	
MutationModule	对单个算法结构细节进行变异	
ScoringModule	执行函数并计算优化目标得分	
AlgorithmPool	管理种群（相似度聚类、保留优秀个体）	
main	组合调度以上模块，进行进化循环

### 模块功能详解
 #### InitializationModule：算法初始化模块
作用：生成一组候选算法函数 score_nodes，作为演化起点。

可选两种方式：

自动生成（调用 LLM，基于 prompt 构造评分函数）

手工设定（内置常见图算法如 PageRank、介数中心性、特征向量中心性等）

输出：算法代码 + 估算的生成代价（cost）

 #### CrossoverModule：算法交叉模块
作用：模拟遗传算法的“交叉”过程，将两个候选函数组合成新的函数。

实现方式：

给出 Algorithm 1 和 Algorithm 2，并标注哪一个更好。

用 LLM 根据两者融合生成新算法（通过 Prompt 编程）

输出：融合后的算法代码 + 成本

#### MutationModule：算法变异模块
作用：在不改变输入输出接口的前提下，对已有算法进行改写优化。

机制：通过提示控制 LLM 进行小幅度结构变异，增加多样性。

参数：stochasticity 控制变异幅度。

#### ScoringModule：评分模块
作用：执行 score_nodes()，评估其对图中关键节点的选择效果。

核心流程：

执行函数并返回节点重要性排序（dict）

移除得分最高的前 N 个节点

评估最大连通子图（GCC）缩小的程度（通过 ANC 或 GCC 尺寸变化）

支持超时控制（timeout），避免死循环代码卡死评估。

输出：算法得分（分值越高表示影响越大）

#### AlgorithmPool：算法池模块
作用：存储当前保留的候选算法，并进行管理与分组。

功能包括：

相似性分群：使用 BERT 编码器计算代码嵌入，按余弦相似度聚类

群体内采样：每个子种群独立进化

添加/替换策略：优胜劣汰

获取当前最佳算法、平均得分、池总规模等

使用 transformers 加载本地 bert-base-uncased 进行代码表示。

#### main.py：主控流程模块
功能：

初始化算法池

执行若干轮进化迭代：

从池中抽样、交叉、变异

执行打分并判断是否为新子种群

更新种群，保存中间结果

达到目标分数或轮数上限后终止

超参数：

number_population：子种群数量

number_of_init_algorithms：初始算法个数

number_for_crossover：交叉采样数

prob_mutation：每次变异概率

similarity_{low,up}_threshold：控制群体划分

####  成果输出
每轮进化会记录并保存如下文件：
algorithms_{epoch}.pkl	当前算法池
score_data.pkl	每轮平均得分与最好得分
population_data.pkl	每轮各子群体信息
API_cost.csv	LLM API 成本汇总

#### 应用场景
该框架适用于以下任务类型：

图结构上的节点重要性识别

演化式算法设计（LLM自动生成策略）

对抗攻击优化（目标函数为削弱图结构）

图神经网络可解释性研究（可与评分函数对比）
