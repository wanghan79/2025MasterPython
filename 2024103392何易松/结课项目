<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>高级弹球游戏</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #f0f0f0;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }

        #game-container {
            position: relative;
            width: 800px;
            height: 600px;
            background-color: #fff;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
        }

        #game-canvas {
            position: absolute;
            top: 0;
            left: 0;
        }

        #ui-canvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
        }

        #game-menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 10;
        }

        .btn {
            padding: 10px 20px;
            margin: 10px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }

        .btn:hover {
            background-color: #45a049;
        }

        #score-display {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 24px;
            color: #333;
            z-index: 5;
        }

        #controls {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 5;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas"></canvas>
        <canvas id="ui-canvas"></canvas>
        <div id="score-display">分数: 0</div>
        <div id="controls">
            <button id="pause-btn" class="btn">暂停</button>
            <button id="reset-btn" class="btn">重置</button>
        </div>
        <div id="game-menu">
            <h1>弹球游戏</h1>
            <button id="start-btn" class="btn">开始游戏</button>
            <button id="settings-btn" class="btn">设置</button>
            <div id="settings-panel" style="display: none; margin-top: 20px;">
                <div>
                    <label for="ball-count">球体数量:</label>
                    <input type="number" id="ball-count" min="1" max="50" value="5">
                </div>
                <div>
                    <label for="gravity">重力:</label>
                    <input type="range" id="gravity" min="1" max="20" value="10">
                    <span id="gravity-value">10</span>
                </div>
                <div>
                    <label for="restitution">弹性:</label>
                    <input type="range" id="restitution" min="0" max="100" value="80">
                    <span id="restitution-value">0.8</span>
                </div>
                <button id="save-settings" class="btn">保存设置</button>
            </div>
            <div id="high-scores" style="margin-top: 20px;">
                <h3>最高分</h3>
                <div id="high-scores-list"></div>
            </div>
        </div>
    </div>

    <script>
        // 游戏常量
        const CANVAS_WIDTH = 800;
        const CANVAS_HEIGHT = 600;
        const FPS = 60;
        const FRAME_TIME = 1000 / FPS;

        // 游戏主类
        class BallGame {
            constructor() {
                this.canvas = document.getElementById('game-canvas');
                this.uiCanvas = document.getElementById('ui-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.uiCtx = this.uiCanvas.getContext('2d');
                this.canvas.width = CANVAS_WIDTH;
                this.canvas.height = CANVAS_HEIGHT;
                this.uiCanvas.width = CANVAS_WIDTH;
                this.uiCanvas.height = CANVAS_HEIGHT;

                this.balls = [];
                this.physicsEngine = new PhysicsEngine();
                this.renderer = new Renderer(this.canvas, CANVAS_WIDTH, CANVAS_HEIGHT);
                this.interactionHandler = new InteractionHandler(this.canvas, this);
                this.score = 0;
                this.highScore = 0;
                this.gameState = 'menu'; // menu, playing, paused, gameover
                this.lastTime = 0;
                this.accumulator = 0;

                this.initEventListeners();
                this.loadSettings();
                this.loadHighScores();
                this.updateUI();
            }

            initEventListeners() {
                document.getElementById('start-btn').addEventListener('click', () => {
                    this.startGame();
                });

                document.getElementById('pause-btn').addEventListener('click', () => {
                    this.togglePause();
                });

                document.getElementById('reset-btn').addEventListener('click', () => {
                    this.resetGame();
                });

                document.getElementById('settings-btn').addEventListener('click', () => {
                    this.toggleSettings();
                });

                document.getElementById('save-settings').addEventListener('click', () => {
                    this.saveSettings();
                });

                document.getElementById('gravity').addEventListener('input', (e) => {
                    document.getElementById('gravity-value').textContent = e.target.value;
                });

                document.getElementById('restitution').addEventListener('input', (e) => {
                    document.getElementById('restitution-value').textContent = (e.target.value / 100).toFixed(1);
                });
            }

            loadSettings() {
                const settings = JSON.parse(localStorage.getItem('ballGameSettings')) || {
                    ballCount: 5,
                    gravity: 10,
                    restitution: 80
                };

                document.getElementById('ball-count').value = settings.ballCount;
                document.getElementById('gravity').value = settings.gravity;
                document.getElementById('gravity-value').textContent = settings.gravity;
                document.getElementById('restitution').value = settings.restitution;
                document.getElementById('restitution-value').textContent = (settings.restitution / 100).toFixed(1);
            }

            saveSettings() {
                const settings = {
                    ballCount: parseInt(document.getElementById('ball-count').value),
                    gravity: parseInt(document.getElementById('gravity').value),
                    restitution: parseInt(document.getElementById('restitution').value)
                };

                localStorage.setItem('ballGameSettings', JSON.stringify(settings));
                this.toggleSettings();
            }

            loadHighScores() {
                this.highScores = JSON.parse(localStorage.getItem('ballGameHighScores')) || [];
                this.updateHighScoresUI();
            }

            saveHighScore() {
                if (this.score > 0) {
                    this.highScores.push({
                        score: this.score,
                        date: new Date().toLocaleDateString()
                    });

                    // 按分数排序并保留前5名
                    this.highScores.sort((a, b) => b.score - a.score);
                    this.highScores = this.highScores.slice(0, 5);

                    localStorage.setItem('ballGameHighScores', JSON.stringify(this.highScores));
                    this.updateHighScoresUI();
                }
            }

            updateHighScoresUI() {
                const highScoresList = document.getElementById('high-scores-list');
                highScoresList.innerHTML = '';

                if (this.highScores.length === 0) {
                    highScoresList.innerHTML = '<p>暂无记录</p>';
                    return;
                }

                const ol = document.createElement('ol');
                this.highScores.forEach(record => {
                    const li = document.createElement('li');
                    li.textContent = `${record.score} 分 (${record.date})`;
                    ol.appendChild(li);
                });

                highScoresList.appendChild(ol);
            }

            toggleSettings() {
                const settingsPanel = document.getElementById('settings-panel');
                settingsPanel.style.display = settingsPanel.style.display === 'none' ? 'block' : 'none';
            }

            startGame() {
                document.getElementById('game-menu').style.display = 'none';
                this.gameState = 'playing';
                this.score = 0;

                const settings = JSON.parse(localStorage.getItem('ballGameSettings')) || {
                    ballCount: 5,
                    gravity: 10,
                    restitution: 80
                };

                // 设置物理参数
                this.physicsEngine.gravity = settings.gravity;
                this.physicsEngine.restitution = settings.restitution / 100;

                // 创建球体
                this.balls = [];
                for (let i = 0; i < settings.ballCount; i++) {
                    const radius = 20 + Math.random() * 10;
                    const x = radius + Math.random() * (CANVAS_WIDTH - radius * 2);
                    const y = radius + Math.random() * (CANVAS_HEIGHT / 2);
                    const color = `hsl(${Math.random() * 360}, 70%, 60%)`;

                    this.balls.push(new Ball(x, y, radius, color));
                }

                // 添加到物理引擎
                this.physicsEngine.objects = this.balls;

                // 开始游戏循环
                this.lastTime = performance.now();
                requestAnimationFrame(this.gameLoop.bind(this));
            }

            togglePause() {
                if (this.gameState === 'playing') {
                    this.gameState = 'paused';
                    document.getElementById('pause-btn').textContent = '继续';
                } else if (this.gameState === 'paused') {
                    this.gameState = 'playing';
                    document.getElementById('pause-btn').textContent = '暂停';
                    this.lastTime = performance.now();
                    requestAnimationFrame(this.gameLoop.bind(this));
                }
            }

            resetGame() {
                this.gameState = 'menu';
                document.getElementById('game-menu').style.display = 'flex';
                document.getElementById('pause-btn').textContent = '暂停';
                this.saveHighScore();
            }

            gameLoop(currentTime) {
                if (this.gameState !== 'playing') return;

                const deltaTime = currentTime - this.lastTime;
                this.lastTime = currentTime;

                // 使用固定时间步长更新物理
                this.accumulator += deltaTime;
                while (this.accumulator >= FRAME_TIME) {
                    this.physicsEngine.update(FRAME_TIME / 1000);
                    this.accumulator -= FRAME_TIME;
                }

                // 更新分数
                this.updateScore();

                // 渲染游戏
                this.renderer.render(this.balls);

                // 继续循环
                requestAnimationFrame(this.gameLoop.bind(this));
            }

            updateScore() {
                // 简单计分：每帧存活球体数量加分
                this.score += this.balls.length;
                document.getElementById('score-display').textContent = `分数: ${this.score}`;

                // 更新最高分
                if (this.score > this.highScore) {
                    this.highScore = this.score;
                }
            }

            updateUI() {
                // 更新UI元素
            }

            addBall(x, y) {
                const radius = 20 + Math.random() * 10;
                const color = `hsl(${Math.random() * 360}, 70%, 60%)`;
                const ball = new Ball(x, y, radius, color);
                this.balls.push(ball);
                this.physicsEngine.objects = this.balls;
            }
        }

        // 球体类
        class Ball {
            constructor(x, y, radius, color) {
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.color = color;
                this.vx = 0;
                this.vy = 0;
                this.mass = radius * radius; // 质量与半径平方成正比
            }

            draw(ctx) {
                ctx.save();
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();

                // 添加高光效果
                const gradient = ctx.createRadialGradient(
                    this.x - this.radius * 0.3,
                    this.y - this.radius * 0.3,
                    this.radius * 0.1,
                    this.x - this.radius * 0.3,
                    this.y - this.radius * 0.3,
                    this.radius * 0.6
                );
                gradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
                gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                ctx.fillStyle = gradient;
                ctx.fill();

                ctx.restore();
            }
        }

        // 物理引擎类
        class PhysicsEngine {
            constructor() {
                this.gravity = 9.8;
                this.restitution = 0.8;
                this.friction = 0.99;
                this.objects = [];
            }

            update(dt) {
                // 更新所有物体位置和速度
                for (const obj of this.objects) {
                    // 应用重力
                    obj.vy += this.gravity * dt;

                    // 应用摩擦力
                    obj.vx *= this.friction;
                    obj.vy *= this.friction;

                    // 更新位置
                    obj.x += obj.vx * dt;
                    obj.y += obj.vy * dt;

                    // 边界检测
                    this.handleBoundaryCollision(obj);
                }

                // 检测物体间碰撞
                this.handleObjectCollisions();
            }

            handleBoundaryCollision(obj) {
                // 左边界
                if (obj.x - obj.radius < 0) {
                    obj.x = obj.radius;
                    obj.vx = -obj.vx * this.restitution;
                }

                // 右边界
                if (obj.x + obj.radius > CANVAS_WIDTH) {
                    obj.x = CANVAS_WIDTH - obj.radius;
                    obj.vx = -obj.vx * this.restitution;
                }

                // 上边界
                if (obj.y - obj.radius < 0) {
                    obj.y = obj.radius;
                    obj.vy = -obj.vy * this.restitution;
                }

                // 下边界
                if (obj.y + obj.radius > CANVAS_HEIGHT) {
                    obj.y = CANVAS_HEIGHT - obj.radius;
                    obj.vy = -obj.vy * this.restitution;
                }
            }

            handleObjectCollisions() {
                // 简单的O(n^2)碰撞检测，对于大量物体需要优化
                for (let i = 0; i < this.objects.length; i++) {
                    for (let j = i + 1; j < this.objects.length; j++) {
                        const obj1 = this.objects[i];
                        const obj2 = this.objects[j];

                        const dx = obj2.x - obj1.x;
                        const dy = obj2.y - obj1.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        // 检测碰撞
                        if (distance < obj1.radius + obj2.radius) {
                            // 计算碰撞法线
                            const nx = dx / distance;
                            const ny = dy / distance;

                            // 计算相对速度
                            const vx = obj2.vx - obj1.vx;
                            const vy = obj2.vy - obj1.vy;

                            // 计算相对速度在碰撞法线上的投影
                            const relativeVelocity = vx * nx + vy * ny;

                            // 如果物体正在分离，则不处理碰撞
                            if (relativeVelocity > 0) continue;

                            // 计算冲量
                            const impulse = -(1 + this.restitution) * relativeVelocity /
                                          (1 / obj1.mass + 1 / obj2.mass);

                            // 应用冲量
                            obj1.vx -= impulse * nx / obj1.mass;
                            obj1.vy -= impulse * ny / obj1.mass;
                            obj2.vx += impulse * nx / obj2.mass;
                            obj2.vy += impulse * ny / obj2.mass;

                            // 分离物体，防止粘连
                            const overlap = (obj1.radius + obj2.radius - distance) * 0.5;
                            obj1.x -= overlap * nx;
                            obj1.y -= overlap * ny;
                            obj2.x += overlap * nx;
                            obj2.y += overlap * ny;
                        }
                    }
                }
            }
        }

        // 渲染器类
        class Renderer {
            constructor(canvas, width, height) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.width = width;
                this.height = height;

                // 创建离屏Canvas用于双缓冲
                this.offscreenCanvas = document.createElement('canvas');
                this.offscreenCanvas.width = width;
                this.offscreenCanvas.height = height;
                this.offscreenCtx = this.offscreenCanvas.getContext('2d');
            }

            clear() {
                this.offscreenCtx.clearRect(0, 0, this.width, this.height);

                // 绘制背景
                this.offscreenCtx.fillStyle = '#f8f8f8';
                this.offscreenCtx.fillRect(0, 0, this.width, this.height);

                // 绘制网格线
                this.offscreenCtx.strokeStyle = '#e0e0e0';
                this.offscreenCtx.lineWidth = 1;

                const gridSize = 40;
                for (let x = 0; x < this.width; x += gridSize) {
                    this.offscreenCtx.beginPath();
                    this.offscreenCtx.moveTo(x, 0);
                    this.offscreenCtx.lineTo(x, this.height);
                    this.offscreenCtx.stroke();
                }

                for (let y = 0; y < this.height; y += gridSize) {
                    this.offscreenCtx.beginPath();
                    this.offscreenCtx.moveTo(0, y);
                    this.offscreenCtx.lineTo(this.width, y);
                    this.offscreenCtx.stroke();
                }
            }

            render(objects) {
                // 先在离屏Canvas上绘制
                this.clear();

                // 绘制所有物体
                for (const obj of objects) {
                    obj.draw(this.offscreenCtx);
                }

                // 将离屏内容绘制到主Canvas
                this.ctx.clearRect(0, 0, this.width, this.height);
                this.ctx.drawImage(this.offscreenCanvas, 0, 0);
            }
        }

        // 交互处理器类
        class InteractionHandler {
            constructor(canvas, game) {
                this.canvas = canvas;
                this.game = game;
                this.isDragging = false;
                this.draggedBall = null;
                this.startX = 0;
                this.startY = 0;
                this.trajectoryPoints = [];

                // 绑定事件处理程序
                canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));
                canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));
                canvas.addEventListener('mouseup', this.handleMouseUp.bind(this));
                canvas.addEventListener('mouseleave', this.handleMouseLeave.bind(this));

                // 触摸事件支持
                canvas.addEventListener('touchstart', this.handleTouchStart.bind(this));
                canvas.addEventListener('touchmove', this.handleTouchMove.bind(this));
                canvas.addEventListener('touchend', this.handleTouchEnd.bind(this));
            }

            handleMouseDown(e) {
                if (this.game.gameState !== 'playing') return;

                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                this.startDrag(x, y);
            }

            handleMouseMove(e) {
                if (!this.isDragging) return;

                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                // 更新被拖拽球的位置
                this.draggedBall.x = x;
                this.draggedBall.y = y;

                // 计算并显示轨迹预测
                this.calculateTrajectory(x, y);
            }

            handleMouseUp(e) {
                if (!this.isDragging) return;

                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                this.endDrag(x, y);
            }

            handleMouseLeave(e) {
                if (this.isDragging) {
                    this.cancelDrag();
                }
            }

            handleTouchStart(e) {
                if (this.game.gameState !== 'playing') return;
                e.preventDefault();

                const rect = this.canvas.getBoundingClientRect();
                const touch = e.touches[0];
                const x = touch.clientX - rect.left;
                const y = touch.clientY - rect.top;

                this.startDrag(x, y);
            }

            handleTouchMove(e) {
                if (!this.isDragging) return;
                e.preventDefault();

                const rect = this.canvas.getBoundingClientRect();
                const touch = e.touches[0];
                const x = touch.clientX - rect.left;
                const y = touch.clientY - rect.top;

                // 更新被拖拽球的位置
                this.draggedBall.x = x;
                this.draggedBall.y = y;

                // 计算并显示轨迹预测
                this.calculateTrajectory(x, y);
            }

            handleTouchEnd(e) {
                if (!this.isDragging) return;
                e.preventDefault();

                const rect = this.canvas.getBoundingClientRect();
                const touch = e.changedTouches[0];
                const x = touch.clientX - rect.left;
                const y = touch.clientY - rect.top;

                this.endDrag(x, y);
            }

            startDrag(x, y) {
                // 检测是否点击了球体
                for (const ball of this.game.balls) {
                    if (this.isPointInBall(x, y, ball)) {
                        this.isDragging = true;
                        this.draggedBall = ball;
                        this.startX = x;
                        this.startY = y;

                        // 停止球的运动
                        ball.vx = 0;
                        ball.vy = 0;
                        break;
                    }
                }
            }

            endDrag(x, y) {
                // 计算发射速度
                const dx = this.startX - x;
                const dy = this.startY - y;
                const power = Math.min(Math.sqrt(dx * dx + dy * dy) * 0.2, 500);

                // 设置球体速度
                this.draggedBall.vx = dx * 0.5;
                this.draggedBall.vy = dy * 0.5;

                // 重置拖拽状态
                this.isDragging = false;
                this.draggedBall = null;
                this.trajectoryPoints = [];
            }

            cancelDrag() {
                if (this.draggedBall) {
                    // 如果取消拖拽，将球放回起始位置
                    this.draggedBall.x = this.startX;
                    this.draggedBall.y = this.startY;
                    this.draggedBall.vx = 0;
                    this.draggedBall.vy = 0;
                }

                this.isDragging = false;
                this.draggedBall = null;
                this.trajectoryPoints = [];
            }

            calculateTrajectory(x, y) {
                const dx = this.startX - x;
                const dy = this.startY - y;
                const power = Math.min(Math.sqrt(dx * dx + dy * dy) * 0.2, 500);

                // 模拟轨迹
                const tempBall = new Ball(this.startX, this.startY, this.draggedBall.radius, 'rgba(255, 0, 0, 0.5)');
                tempBall.vx = dx * 0.5;
                tempBall.vy = dy * 0.5;

                this.trajectoryPoints = [];

                // 模拟未来50帧的轨迹
                for (let i = 0; i < 50; i++) {
                    // 应用物理
                    tempBall.vy += this.game.physicsEngine.gravity * (FRAME_TIME / 1000);
                    tempBall.vx *= this.game.physicsEngine.friction;
                    tempBall.vy *= this.game.physicsEngine.friction;

                    tempBall.x += tempBall.vx * (FRAME_TIME / 1000);
                    tempBall.y += tempBall.vy * (FRAME_TIME / 1000);

                    // 边界碰撞检测
                    if (tempBall.x - tempBall.radius < 0) {
                        tempBall.x = tempBall.radius;
                        tempBall.vx = -tempBall.vx * this.game.physicsEngine.restitution;
                    }

                    if (tempBall.x + tempBall.radius > CANVAS_WIDTH) {
                        tempBall.x = CANVAS_WIDTH - tempBall.radius;
                        tempBall.vx = -tempBall.vx * this.game.physicsEngine.restitution;
                    }

                    if (tempBall.y - tempBall.radius < 0) {
                        tempBall.y = tempBall.radius;
                        tempBall.vy = -tempBall.vy * this.game.physicsEngine.restitution;
                    }

                    if (tempBall.y + tempBall.radius > CANVAS_HEIGHT) {
                        tempBall.y = CANVAS_HEIGHT - tempBall.radius;
                        tempBall.vy = -tempBall.vy * this.game.physicsEngine.restitution;
                    }

                    this.trajectoryPoints.push({ x: tempBall.x, y: tempBall.y });
                }

                // 绘制轨迹
                this.drawTrajectory();
            }

            drawTrajectory() {
                const uiCtx = document.getElementById('ui-canvas').getContext('2d');
                uiCtx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

                if (this.trajectoryPoints.length === 0) return;

                uiCtx.beginPath();
                uiCtx.moveTo(this.startX, this.startY);

                for (let i = 0; i < this.trajectoryPoints.length; i++) {
                    const alpha = 1 - i / this.trajectoryPoints.length;
                    uiCtx.strokeStyle = `rgba(255, 0, 0, ${alpha})`;
                    uiCtx.lineWidth = 2;

                    if (i > 0) {
                        uiCtx.lineTo(this.trajectoryPoints[i].x, this.trajectoryPoints[i].y);
                        uiCtx.stroke();
                        uiCtx.beginPath();
                        uiCtx.moveTo(this.trajectoryPoints[i].x, this.trajectoryPoints[i].y);
                    }
                }
            }

            isPointInBall(x, y, ball) {
                const dx = x - ball.x;
                const dy = y - ball.y;
                return dx * dx + dy * dy <= ball.radius * ball.radius;
            }
        }

        // 初始化游戏
        const game = new BallGame();
    </script>
</body>
</html>
