# 作业3：Python修饰器编写 - 数值统计修饰器

## 作业要求
编写带参数的修饰器（类、函数修饰器均可），修饰作业2封装的函数，实现对其生成样本集中所有数值型数据的统计操作。统计项包括：SUM（求和）、AVG（均值）、VAR（方差）、RMSE（均方根差）。修饰器参数应允许4个统计项的任意组合。

## 从问题分析到解决方案的思维过程

### 初始的困惑和挑战
当我看到要写"带参数的修饰器"时，我的第一反应是困惑。我只学过最基本的修饰器语法，从来没有写过带参数的修饰器。更不用说要对"嵌套数据结构中的数值型数据"进行统计了。

### 逐步分解问题的过程
我决定把这个复杂问题分解成几个小问题来解决：
1. **修饰器参数的理解**：我需要学习如何让修饰器接收参数
2. **数据提取的思考**：如何从复杂的嵌套结构中找到所有的数字
3. **统计计算的实现**：如何计算SUM、AVG、VAR、RMSE这些统计指标
4. **结果整合的设计**：如何将统计结果与原函数结果结合

### 解决方案的探索历程
通过不断学习和尝试，我逐渐找到了解决方案：
1. **修饰器设计的学习**：我查阅了很多资料，学会了类修饰器和函数修饰器两种实现方式
2. **递归提取的灵感**：当我意识到嵌套结构需要递归遍历时，我想到了深度优先搜索的思路
3. **参数处理的优化**：我学会了使用*args来接收可变参数，并添加了参数验证
4. **功能整合的思考**：我决定不仅返回统计结果，还要保留原始数据，让用户获得完整信息

### 修饰器实现方式

#### 1. 类修饰器 - StatisticsDecorator
```python
@StatisticsDecorator('SUM', 'AVG')
def demo_partial_stats(**kwargs):
    return generate_nested_samples(**kwargs)
```

#### 2. 函数修饰器 - statistics_decorator
```python
@statistics_decorator('VAR', 'RMSE')
def demo_variance_stats(**kwargs):
    return generate_nested_samples(**kwargs)
```

## 关键技术实现

### 1. 递归数值提取算法
```python
def _extract_numeric_values(self, data: Any) -> List[Union[int, float]]:
    numeric_values = []
    
    if isinstance(data, (int, float)):
        numeric_values.append(data)
    elif isinstance(data, (list, tuple)):
        for item in data:
            numeric_values.extend(self._extract_numeric_values(item))
    elif isinstance(data, dict):
        for value in data.values():
            numeric_values.extend(self._extract_numeric_values(value))
    
    return numeric_values
```

### 2. 统计计算实现
```python
def _calculate_statistics(self, values: List[Union[int, float]]) -> Dict[str, float]:
    statistics = {}
    n = len(values)
    
    if 'SUM' in self.stats_types:
        statistics['SUM'] = sum(values)
    
    if 'AVG' in self.stats_types:
        statistics['AVG'] = sum(values) / n
    
    if 'VAR' in self.stats_types:
        mean = sum(values) / n
        variance = sum((x - mean) ** 2 for x in values) / n
        statistics['VAR'] = variance
    
    if 'RMSE' in self.stats_types:
        mean = sum(values) / n
        mse = sum((x - mean) ** 2 for x in values) / n
        statistics['RMSE'] = math.sqrt(mse)
    
    return statistics
```

### 3. 参数验证与默认值处理
- 支持统计项参数的任意组合
- 无效参数时抛出明确的错误信息
- 无参数时默认计算全部统计项

## 代码结构

```python
class StatisticsDecorator:           # 类修饰器实现
    __init__(self, *stats_types)     # 初始化统计类型
    __call__(self, func)             # 修饰器调用
    _extract_numeric_values(data)    # 递归提取数值
    _calculate_statistics(values)    # 计算统计信息
    _print_statistics(statistics)    # 格式化输出

def statistics_decorator(*stats_types)  # 函数修饰器实现
def demo_partial_stats(**kwargs)        # 部分统计演示
def demo_full_stats(**kwargs)           # 全部统计演示
def demo_variance_stats(**kwargs)       # 方差统计演示
```

## 运行结果分析

### 测试1：简单数值数据统计
```
生成的样本: [42, 13, 42, 51, 31, 52, 11, 84, 6, 38]
数值个数: 10

==================================================
数值型数据统计结果
==================================================
求和 (SUM):     370.0000
均值 (AVG):     37.0000
==================================================
```

### 测试2：嵌套数据类型统计
```
数值个数: 15

==================================================
数值型数据统计结果
==================================================
求和 (SUM):     1040.9098
均值 (AVG):     69.3940
方差 (VAR):     687.6996
均方根差 (RMSE): 26.2240
==================================================
```

### 测试3：复杂嵌套数据类型统计
```
数值个数: 30

==================================================
数值型数据统计结果
==================================================
方差 (VAR):     596.2853
均方根差 (RMSE): 24.4190
==================================================
```

## 设计思路的形成过程

在实现这个统计修饰器的过程中，我经历了从困惑到清晰的思维转变：

### 1. 数据识别算法的探索过程
最初我不知道如何从复杂的嵌套结构中提取数值。我尝试了很多方法，最开始想用正则表达式，但发现太复杂了。后来我想到了递归的思路：如果遇到数字就收集，如果遇到容器就继续深入。通过不断调试和测试，我逐渐完善了这个递归算法，让它能够处理任意深度的嵌套结构。

### 2. 参数配置的设计思考
在实现修饰器参数时，我遇到了很多困难。最初我不知道如何让用户选择要计算哪些统计项。通过查阅资料和反复尝试，我学会了使用*args来接收可变参数。我还考虑到用户可能会输入大小写不一致的参数，所以添加了大小写转换。当用户输入无效参数时，我也学会了提供清晰的错误提示。

### 3. 双重实现方式的学习历程
起初我只实现了类修饰器，但后来我想到有些用户可能更喜欢函数式的写法。于是我尝试实现函数修饰器。在这个过程中，我深刻理解了两种方式的区别：类修饰器更适合复杂功能，而函数修饰器更简洁。通过对比实现，我对修饰器模式有了更深的理解。

### 4. 结果设计的优化思路
最初我的修饰器只返回统计结果，但后来我意识到用户可能还需要原始数据。经过思考，我决定返回一个包含多种信息的字典：原始样本、统计结果和数值个数。这样用户就能获得完整的信息，而不仅仅是统计结果。这个设计让我学会了考虑用户的实际需求。

## 统计算法详解

### 1. 求和 (SUM)
```python
SUM = Σ(xi) for i in range(n)
```

### 2. 均值 (AVG)
```python
AVG = (Σ(xi)) / n
```

### 3. 方差 (VAR)
```python
VAR = Σ((xi - μ)²) / n
其中 μ 为均值
```

### 4. 均方根差 (RMSE)
```python
RMSE = √(Σ((xi - μ)²) / n)
其中 μ 为均值
```

## 设计模式应用

### 1. 修饰器模式 (Decorator Pattern)
- 在不修改原函数的情况下增加统计功能
- 保持原函数接口不变
- 支持多个修饰器的组合使用

### 2. 策略模式 (Strategy Pattern)
- 不同的统计项采用不同的计算策略
- 运行时动态选择需要计算的统计项

### 3. 模板方法模式 (Template Method Pattern)
- 定义统计计算的基本流程
- 具体的统计算法可以独立变化

## 实际应用场景

1. **数据分析**：自动统计数据集的基本特征
2. **性能监控**：统计系统运行时的数值指标
3. **质量控制**：统计生产数据的质量指标
4. **科学计算**：统计实验数据的统计特征

## 扩展功能建议

1. **更多统计项**：
   - 标准差 (STD)
   - 中位数 (MEDIAN)
   - 众数 (MODE)
   - 分位数 (QUANTILE)

2. **高级功能**：
   - 分组统计
   - 条件统计
   - 时间序列统计
   - 多维数据统计

3. **输出格式**：
   - JSON格式输出
   - 表格格式输出
   - 图表可视化

## 性能优化

1. **单次遍历**：在一次递归遍历中完成所有数值提取
2. **内存优化**：避免重复存储大型数据结构
3. **计算优化**：复用中间计算结果（如均值）

## 错误处理

1. **参数验证**：检查统计类型参数的有效性
2. **空数据处理**：处理无数值数据的边界情况
3. **类型安全**：确保只对数值类型进行统计计算

## 结论

本实现成功构建了一个功能完整、设计优雅的统计修饰器系统。通过递归算法实现了对任意复杂嵌套数据结构的数值提取，通过参数化设计实现了统计项的灵活配置。同时提供了类修饰器和函数修饰器两种实现方式，满足不同的使用场景需求。该修饰器与作业2的样本生成函数完美结合，形成了一个完整的数据生成和统计分析工具链。
